\section{Container configuration}

Als we Docker containers gebruiken, moeten de containers zelf ook goed geconfigureerd zijn. Een groot deel van de veiligheid van de containers zelf hangt af van hoe het ´docker run´ commando gebruikt wordt. Daarnaast zijn er ook nog een aantal punten waarvoor er moet worden oppast of die kunnen geoptimaliseerd worden op de container zelf.

\subsection{docker run commando configureren}

Elke container word opgestart met het commando ´docker run [OPTIONS] IMAGE [COMMAND] [ARG...]´. Met dit commando kunnen aan de hand van onze zelfgemaakt Docker image of een gedownloade Docker image een container aanmaken en direct opstarten. Doordat dit een van de belangrijkste commando's is die bij Docker hoort, is het uiteraard ook een van de krachtigste. Er moeten dus wel beter  enkele dingen in gedachten gehouden worden bij het uitvoeren van dit commando.

Bij het uitvoeren van het standaard ´docker run´ commando, namelijk ´docker run IMAGE´ zijn er veel dingen die standaard in orde zijn. Uiteraard zijn er dingen waarmee er normaal geen problemen mee mogen zijn maar uitzonderlijk kunnen hier toch problemen opduiken.

Eén van deze dingen is de standaard Linux Kernel Capabilities die de container heeft. De werking Linux Kernel Capabilities valt buiten de scope van deze Bachelorproef en wordt daarom ook hier niet uitgebreid behandeld. Maar sterk vereenvoudigd is dit de basis instructieset die een linux besturingssysteem bezit, deze instructies zijn als gewone gebruiker niet allemaal toegankelijk maar de root user kan elke instructie uitvoeren. Docker heeft uit voorzorg hiervoor deze lijst met Capabilities al sterk verminderd in vergelijking met de gewone Linux Kernel Capabilities. Dit zorgt ervoor dat de root user in een container veel minder kan dan een root user op een gewoone machine. Bij meeste use cases is het ook niet noodzakelijk om de containers volledige root rechten te verschaffen. Hiervoor kunnen we dus de Linux Kernel Capabilities per container gaan tweaken en enkel privileges toewijzen aan de containers die ze echt nodig hebben. Om deze beperking te omzeilen, kunnen Docker containers ook met de optie ´--privileged´ opstarten. Dit geeft de container alle Kernel Capabilities die het hostsysteem heeft en wordt dus best, buiten in enkele zeer specifieke use cases, vermeden.

Naast de mogelijkheid om de standaard Kernel Cabapilities aan te passen van de containers hebben we ook de mogelijkheid om het processor en geheugen gebruik te limiteren. Docker containers kunnen zonder verdere configuratie het complete geheugen gebruiken van de host, hierdoor kunnen andere containers zonder geheugen geraken en dit kan voor problemen zorgen. De mogelijkheid dat een container het complete geheugen van het hostsysteem in beslag neemt, is zeker iets waar rekening mee gehouden moet worden. Hiervoor bestaat de optie ´-m´. Hiermee kan de maximale hoeveelheid geheugen die een container mag gebruiken bepaald worden. Een optie om de minimale hoeveelheid geheugen voor containers met een kritieke rol vast te leggen ontbreekt daarbij heelaas. Hierdoor kunnen deze kritieke containers ook zonder geheugen geraken waardoor de werking van ons systeem in gedrang komt. Een mogelijkheid om dit te vermijden zou kunnen zijn, aan elke container een bepaalde hoeveelheid geheugen toewijzen waardoor als de som gemaakt wordt van alle geheugengebruik die som lager blijft dan de maximale hoeveelheid geheugen dat de host ter beschikking kan stellen. Maar dan moet elke keer als een nieuwe container teogevoegd wordt elke container opnieuw opstarten met een andere hoeveelheid toegewezen geheugen. Hierdoor wordt er verloren aan flexibiliteit die  net verkregen wordt door Docker te gebruiken, en dit is dus niet aan te raden. Daarnaast is er ook het gebruik van de Central Processing Unit (CPU). Elke container gebruikt standaard een gelijke hoeveelheid van de CPU. De optie die gebruikt wordt om het cpu gebruik te bepalen is de ´-c´ of de cpu-shares optie. Standaard heeft deze een waarde van 1024, als alle containers deze waarde hebben, krijgen ze allemaal gelijke prioriteit op de cpu. Door deze waarde te verhogen of verlagen kan er desgewenst een hogere of lagere prioriteit ingesteld voor de container met deze aangepaste optie. 

Het is maar op het moment dat dit standaard run commando aangepast wordt met opties dat er enkele dingen zijn waarvoor er best wordt opgelet. Wanneer een Docker run commando wordt uitgevoerd, zijn er twee dingen die in opties kunnen toevoegd worden waar men toch iets voorzichtiger mee moet zijn. Namelijk netwerk configuratie en mounts van host mappen in de container.

Netwerkconfiguratie van Docker is, als er niets aan is aangepast, tamelijk robuust. Maar indien aan dit commando aangepast wordt, is bestaat er de kans dat deze robuustheid te ondermijnd wordt. Eén van de elementen hierbij is poorten. Bij het verbinden naar buiten de machine, waarop een container opereert, moet zowel een poort op de host als een poort op de container worden opengesteld. Op deze manier worden deze poorten verbonden, waardoor het netwerkverkeer die op de gedefinieerde poort van de host toekomt, doorgezonden wordt naar de verbonden poort op de container. Een best practice hierbij is om altijd de volledige connectie te definiëren, dit wil zeggen dat zowel de de externe interface, de externe host poort als de interne container poort meegeven wordt in het run commando. Hierbij worden op de container best enkel poorten geopend die effectief gebruikt worden door deze container. Dit zorgt ervoor dat het aanvalsvlak via het netwerk op deze container verkleint. TCP/IP poorten onder 1024 op de host machine worden best ook vermeden om op te binden. Uiteraard zijn er services die hier op moeten binden, zoals een HTTP-proxy die op poort 80 moet luisteren om te kunnen functioneren, die ook veiliger als ze hierop gebonden zijn. Een goede maatstaf om te weten opdat een container op een geprivilegieerde poort gebonden moet worden, is kijken indien men de service die in de container draait, ook wanneer die op een virtuele machine draait, op een poort onder 1024 zou binden. Daarnaast hebben we net zoals bij Kernel Capabilities ook bij networking een manier om het intern Docker netwerk te omzeilen. Een container gebruikt standaard een bridged netwerk. Hierdoor wordt deze container in een aparte netwerk stack gestoken. Als we de optie ´--net=host´ meegeven overschrijven we dit en geven we de container toegang tot alle netwerkinterfaces van de host machine. Dit moet, tenzij in zeer specifieke toepassingen, niet gebruikt worden.


%TODO Mounting van directories
\subsection{Container configuratie}

Om extra beveiliging te voorzien voor de Docker containers is het mogelijk (indien ondersteund door de host besturingssysteem) om AppArmor en SeLinux te gebruiken. Met AppArmor is het mogelijk om voor elke container apart een AppArmor profiel te maken. SeLinux voor Docker moet aangezet worden bij het opstarten van de Docker Daemon. Dit kan simpel gedaan worden door de Daemon bij het starten de optie ´--selinux-enabled´ mee te geven. Hierna kunnen we SeLinux security opties meegeven aan containers. Zowel AppArmor en Selinux zorgen ervoor dat we elke container individueel kunnen configureren op vlak van security. Het individueel configureren van SeLinux en AppArmor voor containers kan vergeleken worden met het configureren voor processen op een niet-Docker systeem. Dit is buiten de scope van deze Bachelorproef en hier wordt daarom niet verder op ingegaan.

Daarnaast is een element dat we moeten bekijken wat we nu precies in een container willen draaien qua processen. Het idee achter Docker is om één enkele applicatie per container op te delen. Docker luistert standaard enkel op één hoofdproces. Dus indien we meerdere processen willen uitvoeren op één container, die niet gemaakt zijn om vanuit één hoofdproces op te starten en informatie terug door te geven via dit hoofd proces, moeten we procesbeheer gaan bijvoegen in de container. Dit zorgt er onder andere voor dat een container, wat algemeen gezien een simpel iets is, weer zeer complex wordt. Anderzijds zorgt dit ervoor dat je de processen binnen de container niet meer op een optimale manier kunt monitoren met Docker. Een voorbeeld hiervan zou zijn indien zowel de applicatie als de database op eenzelfde container staat. Inden deze configuratie zou gebruikt worden, zal er al snel opgemerkt worden dat het heel wat makkelijker zou zijn om gewoon de database uit de applicatie container te halen en in zijn eigen container op te starten. Dit geeft ons naast een robuuster systeem (als de applicatie crasht zou het kunnen dat dit de database mee doet crashen indien het op dezelfde container draait) ook een meer schaalbaar systeem door gewoon meer applicatiecontainers te linken met dezelfde database container. Een ander voorbeeld van een nutteloos element om in een container te draaien is ssh, containers hebben in de meeste gevallen geen ssh nodig. Alle containers zijn namelijk al toegankelijk via het hostsysteem met het commando ´docker exec CONTAINER´ dus is daar de meest aangewezen plaats om SSH te installeren. Met een installatie van ssh op de hostmachine, kan er met een ssh connectie naar de host makkelijk ingelogd worden op elke container.
